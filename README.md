# 総合仕様書：Gemini Puzzle

このドキュメントは、ウェブ上で動くパズルゲーム「Gemini Puzzle」の設計図（仕様書）です。JavaScript、HTML、CSSという3つの技術を使って作られています.

---

## 1. `index.html` の仕様書

### 1.1. 概要
`index.html`は、このゲームの「骨格」を作るファイルです。ウェブページに何が表示されるか、その内容と構造を定義します。例えば、ゲームのタイトルや、実際にパズルが配置される場所などを設定しています.

### 1.2. 目的
* ゲームの画面（ユーザーインターフェース）の基本的な要素を配置すること.
* CSS（見た目を整える）ファイルとJavaScript（動きを作る）ファイルを読み込むこと.

### 1.3. 主要な要素と役割
* **`<!DOCTYPE html>`**: これは「HTML5」という最新のルールで書かれたウェブページですよ、とブラウザに教えています.
* **`<html lang="ja">`**: このウェブページは日本語で書かれています、という意味です.
* **`<head>`**: ウェブページには直接見えないけれど、大切な情報が書かれる場所です.
    * **`<meta charset="UTF-8">`**: 文字エンコーディングをUTF-8に設定し、様々な言語の文字が正しく表示されるようにします.
    * **`<meta name="viewport" ...>`**: レスポンシブデザインのための設定で、デバイスの幅に合わせてビューポートの幅を調整し、初期ズームレベルを1.0に設定します.
    * **`<title>Gemini Puzzle</title>`**: ブラウザのタブやウィンドウのタイトルバーに表示されるページのタイトルを設定します.
    * **`<link rel="preconnect" ...>`**: Google Fontsへの接続を最適化し、フォントの読み込みを高速化します.
    * **`<link href="..." rel="stylesheet">`**: `style.css`というファイル（見た目を担当）を読み込んでいます。これにより、ゲームの見た目がきれいになります.
* **`<body>`**: ウェブページに実際に表示される内容が書かれる場所です.
    * **`<div id="game-container">`**: ゲーム全体のコンテナ要素です。中央寄せや背景スタイリングが適用されます.
        * **`<div id="game-info">`**: ゲームに関する情報を表示する領域です.
            * **`<h1>GEMINI PUZZLE</h1>`**: ゲームのタイトルです.
            * **`<h2>コンボ: <span id="combo-count">0</span></h2>`**: 現在のコンボ数を表示するための見出しと、その値を動的に更新するための`<span>`要素（`combo-count`）です.
        * **`<div id="game-board"></div>`**: ドロップが配置されるメインのゲームボード領域です。JavaScriptによって内部にドロップ要素が生成されます.
    * **`<script src="script.js"></script>`**: ゲームのロジックとインタラクティブ性を実装する`script.js`ファイルを読み込みます.このスクリプトはHTMLの最後に配置されており、DOM要素が完全にロードされてからスクリプトが実行されるように意図されています.

### 1.4. `index.html`の処理フロー (Mermaid)

```mermaid
graph TD
    A[ブラウザがindex.htmlを読み込み開始] --> B[HTMLの骨格を構築]
    B --> C[head内のメタ情報やタイトルを設定]
    C --> D{Google Fontsやstyle.cssを読み込む}
    D --> E[body内の要素を配置]
    E --> F[ゲームコンテナと情報表示エリアを配置]
    F --> G[ゲームボードの枠を配置]
    G --> H[script.jsを読み込み実行]
    H --> I[ページが表示され、ゲーム開始準備完了]
2. style.css の仕様書
2.1. 概要
style.cssは、このゲームの「見た目」を整えるファイルです。HTMLで作られた要素（ゲームボードやドロップなど）の色、形、配置、そしてアニメーションなどを指示します.これにより、ゲームが魅力的で分かりやすくなります.

2.2. 目的
ウェブページ全体のレイアウトや背景色、文字のスタイルを設定すること.

ゲームボードやドロップのサイズ、形、色、影などのデザインを定義すること.

ドロップが動いたり消えたりする際の滑らかなアニメーションを設定すること.

2.3. 主要なスタイルと役割
body:

font-family: ゲーム全体の文字を「M PLUS Rounded 1c」という丸みのあるフォントにします.

display: flex; align-items: center; justify-content: center;: ゲーム全体が画面の真ん中に来るように配置します.

background: linear-gradient(...): 背景にきれいなグラデーションの色をつけます.

color: white; text-shadow: ...: 文字を白色にし、視認性を高めるための影を適用します.

#game-container:

background: rgba(255, 255, 255, 0.1);: 半透明の背景をつけます.

padding: 40px; border-radius: 20px; box-shadow: ...: 周りに余白をつけ、角を丸くし、立体的な影をつけてゲームの枠を飾ります.

#game-info h1, #game-info h2:

font-size; margin-bottom;: ゲームのタイトルとコンボ表示のフォントサイズと下マージンを調整します.

#game-board:

position: relative;: 子要素のドロップ（.drop）を絶対配置するための基準点となります.

width: 360px; height: 300px;: ゲームボードの固定サイズ（6列 * 60px = 360px, 5行 * 60px = 300px）を設定します.

border: 3px solid ...; border-radius: 10px; background: ...;: ボードの見た目を整えるためのボーダー、角丸、背景を設定します.

.drop:

position: absolute;: JavaScriptによって計算された位置にドロップを正確に配置できるようにします.

width: 58px; height: 58px; border-radius: 50%;: ドロップのサイズ、円形、ボックスモデルを設定します.

cursor: pointer;: マウスをドロップの上に置くと、指の形に変わるようにします.

transition: transform 0.25s ease-out, opacity 0.3s, box-shadow 0.2s;: ドロップの移動、透明度、影の変化に滑らかなアニメーション効果を適用します.

box-shadow: ...; border: ...;: ドロップに立体感を与えるための影と白いボーダーを設定します.

.dragging:

ドロップをドラッグしているときに一時的に追加される特別な見た目です.

opacity: 0.8;: 半透明になります.

z-index: 100;: 他の要素の上に表示されます.

transform: scale(1.15);: 少し大きくなります.

transition: none;: ドラッグ中は滑らかなアニメーションを一時的に止めて、すぐにマウスの動きに追従するようにします.

.matched:

マッチして消えるドロップに一時的に追加されるクラスです.

animation: disappear 0.5s forwards ease-in-out;: disappearという名前の消滅アニメーションを0.5秒間実行します.

@keyframes disappear:

disappearアニメーションの具体的な動きを定義しています.

0%: アニメーションの最初（通常サイズ、回転なし、不透明）.

100%: アニメーションの最後（完全に縮小、180度回転、透明）.

2.4. style.cssの処理フロー (Mermaid)
コード スニペット

graph TD
    A[HTML要素のスタイルを定義] --> B[body: 全体レイアウトと背景]
    B --> C[#game-container: ゲーム枠のデザイン]
    C --> D[#game-info: タイトルとコンボ表示の文字サイズ]
    D --> E[#game-board: パズルボードの枠と基準位置]
    E --> F[.drop: ドロップの基本デザインとアニメーション設定]
    F --> G[.dragging: ドラッグ中のドロップの特殊表示]
    G --> H[.matched: 消えるドロップの特殊表示]
    H --> I[@keyframes disappear: 消滅アニメーションの定義]
    I --> J[ブラウザがHTMLにCSSを適用し見た目を整形]
3. script.js の仕様書
3.1. 概要
script.jsは、このゲームの「頭脳」であり「動き」を作るファイルです。ゲームのルール、プレイヤーの操作（ドラッグ＆ドロップ）、マッチの判定、コンボの計算、ドロップの消去と新しいドロップの補充といった、ゲームの全ての機能とインタラクション（相互作用）を制御します.

3.2. 目的
ゲームボードを初期化し、ランダムなドロップで埋めること.

プレイヤーがドロップをドラッグ＆ドロップで操作できるようにすること.

同じ色のドロップが3つ以上並んだときに、それらをマッチとして検出すること.

マッチしたドロップを消去し、コンボ数をカウントすること.

消えたドロップの場所に、上から新しいドロップを補充し、落下させること.

これらの処理を滑らかなアニメーションで実現すること.

3.3. 主要な機能と役割
DOMContentLoaded: ウェブページの内容が全て準備できてから、ゲームのコードを実行するための指示です.

変数と定数:

gameBoard, comboCountElement: DOM要素への参照です.

rows, cols, dropSize: ゲームボードの行数、列数、ドロップ1つあたりのサイズです.

dropTypes: ドロップの色を定義する配列です.

board: ゲームの論理的な状態を管理する2D配列です。各要素はDOMのドロップ要素への参照かnullです.

draggedDrop: 現在ドラッグされているドロップのDOM要素への参照です.

isAnimating: アニメーションが実行中であるかを示すフラグです。アニメーション中にドロップ操作を無効にするために使用されます.

initializeBoard():

ゲームボードをリセットし、board配列を初期化します.

全てのセルにランダムな色の新しいドロップを作成し、DOMに追加します.

初期配置で3つ以上のドロップが揃わないように、マッチがある場合はremoveAndRefillForInitializationを繰り返し呼び出して修正します.

最後に全てのドロップの位置を更新します.

createDrop(r, c, type):

新しいドロップのDOM要素を作成し、指定された行、列、色のデータ属性とスタイルを設定します.

updateDropPosition(drop):

指定されたドロップのtransformスタイルを更新し、論理ボード上の位置（dataset.row, dataset.col）に基づいてDOM上で視覚的に移動させます.

updateAllDropPositions():

board配列内の全てのドロップに対してupdateDropPositionを呼び出し、全体の位置を更新します.

ドラッグ＆ドロップの処理:

mousedownイベント: マウスボタンが押されたときにドラッグを開始します。ドラッグ中のドロップにdraggingクラスを追加し、mousemoveとmouseupイベントリスナーを登録します.

onMouseMove(e): マウスが移動するたびにドラッグ中のドロップのtransformスタイルを更新してカーソルに追従させます。ドロップが別のセルに移動した場合、swapDropsを呼び出して対象のドロップと位置を交換します.

onMouseUp(): マウスボタンが離されたときにドラッグを終了します。draggingクラスを削除し、イベントリスナーを解除します。全てのドロップの位置を更新した後、handleMatchesを呼び出してマッチ処理を開始します.

swapDrops(drop1, drop2): 論理ボード（board配列）とDOM要素のdataset.row/dataset.col属性を更新することで、2つのドロップを交換します.

マッチ処理（ゲームの核心）:

handleMatches() (非同期関数 - async/awaitを使用):

ゲームのメインループの一つで、ドロップを消す、落とす、補充という一連の流れを管理します.

isAnimatingフラグを設定し、アニメーション中に操作を無効にします.

無限ループでマッチがなくなるまで処理を繰り返します（連鎖対応）.

findMatchGroups()を呼び出して、現在のボード上の全てのマッチグループを検出します.

マッチグループが存在しない場合、ループを終了します.

マッチグループを消滅アニメーションの表示順（下から上、同じ行なら左から右）でソートします.

コンボ数を更新し、画面に表示します.

各マッチグループに対してremoveMatches()を呼び出し、ドロップを消去します。各グループの消去間に250msの遅延を設けます.

全ての消去アニメーション完了後、500msの遅延を設けます.

shiftAndRefill()を呼び出して、消えたドロップのスペースを埋めるために残りのドロップを落下させ、新しいドロップを補充します.

300msの遅延を設けて、落下アニメーションが完了するのを待ちます.

ループ終了後、isAnimatingフラグをリセットします.

findMatchGroups():

ボード全体を走査し、縦横に3つ以上同じ色のドロップが連続している箇所を特定し、potentialMatchesセットに追加します.

potentialMatches内のドロップから、隣接する同じ色のドロップを探索し、連結された「塊」としてマッチグループ（配列の配列）を形成します.

removeMatches(matches):

引数で与えられたマッチしたドロップの配列を反復処理し、それぞれのドロップにmatchedクラスを追加します。これにより、CSSアニメーション（disappear）が適用されます.

同時に、論理ボード（board配列）内の対応する位置のドロップをnullに設定し、ドロップが消えたことを論理的に記録します.

shiftAndRefill():

フェーズ1 (論理シフト): 論理ボード内を一番下から上に走査し、nullのセルを見つけた場合、その上に存在するドロップを下に移動させ、論理ボード上の位置を更新します.

フェーズ2 (DOM削除): matchedクラスが付与されている全てのDOMドロップ要素をドキュメントから削除します.

フェーズ3 (新規ドロップ生成): 論理ボード上でnullになっている（空いている）全てのセルに対して、新しいランダムな色のドロップを作成します。これらの新しいドロップは、落下アニメーションのために最初は画面外の上部に配置されます.

フェーズ4 (DOM位置更新): 短い遅延（50ms）の後、updateAllDropPositions()を呼び出し、全てのドロップ（既存のシフトされたドロップと新しく生成されたドロップ）を最終的なグリッド位置にアニメーションさせます.

removeAndRefillForInitialization(matches):

この関数はゲームの「初期化」の時だけにしか使われません.

初期ボード生成時に見つかったマッチしたドロップの色をランダムに再設定し、マッチが存在しない状態になるまで繰り返します.

sleep(ms):

指定した時間（ミリ秒）だけ、プログラムの実行を一時停止させるための非同期ヘルパー関数です。async/await構文と組み合わせて、アニメーションのタイミングや処理の順序を制御するために使用されます.

initializeBoard()の呼び出し:

全てのコードが読み込まれた後、この関数が実行され、ゲームが開始されます.

3.4. script.jsの処理フロー (Mermaid)
コード スニペット

graph TD
    A[DOMContentLoadedイベント発生] --> B{initializeBoard()を呼び出しゲーム開始準備}
    B --> C[ボード初期化: 全マスにドロップ生成]
    C --> D{初期配置でマッチがないかチェック}
    D -- マッチあり --> E[removeAndRefillForInitialization: マッチしたドロップの色を再設定]
    E --> D
    D -- マッチなし --> F[updateAllDropPositions: 初期ドロップ位置調整]

    F --> G{ゲームボードにマウスイベントリスナー設定}

    G -- マウスダウン --> H[draggedDropをセット、draggingクラス追加]
    H --> I{mousemove/mouseupイベントリスナー登録}

    I -- mousemove --> J[ドロップをマウスに追従して移動]
    J -- 別マスに入ったら --> K[swapDrops: ドロップの論理・表示位置を交換]
    K --> J

    I -- mouseup --> L[draggingクラス削除、イベントリスナー解除]
    L --> M[updateAllDropPositions: 最終位置調整]
    M --> N{handleMatches(): マッチ処理開始}

    N --> O{アニメーション中フラグON}
    O --> P{findMatchGroups(): マッチグループを検出}
    P -- マッチなし --> Q{アニメーション中フラグOFF}
    Q --> R[処理終了]

    P -- マッチあり --> S[マッチグループを消滅順にソート]
    S --> T[コンボ数更新・表示]
    T --> U{各マッチグループをループ}
    U --> V[removeMatches(): matchedクラス追加、論理ボードから削除]
    V --> W[sleep(250): 次の消滅アニメーションまで待機]
    W --> U
    U --> X[sleep(500): 全消滅アニメーション完了まで待機]
    X --> Y[shiftAndRefill(): ドロップ落下と補充]
    Y --> Z[sleep(300): 落下アニメーション完了まで待機]
    Z --> N
